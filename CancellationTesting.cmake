
# Idea: a function like mtm_auto_cancellation_test that would discover what files are in a directory
# make INPUT_AUDIO a variadic argument and remove SIDECHAIN_INPUT INPUT_AUDIO not required if
# INPUT_MIDI is given

include_guard (GLOBAL)

find_program (PLUGALYZER_PROGRAM plugalyzer DOC "Plugalyzer executable")

define_property (
	DIRECTORY
	PROPERTY CANCELLATION_REGEN_TARGET
	INHERITED
	BRIEF_DOCS "Name of custom target to drive reference file regeneration"
	FULL_DOCS
		"Reference audio files for all cancellation tests in this directory can be regenerated by the custom target named in this property"
)

#[[
	add_plugin_cancellation_test (
		<pluginTarget>
		REFERENCE_AUDIO <audioFile>
		INPUT_AUDIO <audioFile>
		[RMS_THRESH <thresh>]
		[STATE_FILE <jsonFile>]
		[PARAMS <name>:<value>[:n] <name>:<value>[:n] ...]
		[SIDECHAIN_INPUT <audioFile>]
		[INPUT_MIDI <midiFile>]
		[BLOCKSIZE <size>]
		[TEST_PREFIX <prefix>]
		[REGEN_TARGET <target>]
	)

	Adds an audio cancellation test. The purpose of a cancellation test is to verify that a plugin, given the same
	audio input and parameter values, will produce the same output as a known "good" version (ie, the last tagged
	release, etc). This function registers tests that perform the following steps:
	- Render audio using the given input audio, MIDI, and parameter settings. This is done using Plugalyzer.
	- Calculate the difference between the rendered audio and the reference audio. In this implementation, we consider
	the rendered test signal to be the reference signal + noise, so we attempt to measure the amount of noise by
	subtracting the reference audio from the rendered audio and taking the RMS of the result.
	- Fail the cancellation test if the determined noise level is higher than RMS_THRESH

	The determined noise level is also output in a manner known to CTest, so that it will, by default, be included
	in CDash dashboards as a numeric measurement for historical tracking and analysis. The rendered and reference
	audio files will be uploaded to CDash as well, for archival purposes.

	These tests require Plugalyzer to be found in the PATH, CMAKE_PREFIX_PATH, or CMAKE_PROGRAM_PATH. Its path can
	also be set explicitly using the PLUGALYZER_PROGRAM variable. It can be built from source; the code is available
	from https://github.com/CrushedPixel/Plugalyzer.

	RMS_THRESH determines how strict the test is; a value of 0 will require that the rendered audio is exactly the same
	as the reference audio with no deviation, and a value of 1 would allow a completely different audio output to
	"pass" the cancellation test. RMS threshold values may require tuning on a per-cancellation-test basis over time.

	STATE_FILE is a JSON file containing parameter values, and can even describe parameter automations; see
	https://github.com/CrushedPixel/Plugalyzer for more details about the file format. Non-automated parameter values
	can also be set individually using the PARAMS keyword. For PARAMS, you can specify the parameter name or index.

	TEST_PREFIX defines a prefix for the test names, and defaults to <pluginTarget>.Cancellation.<ReferenceFileName>

	REGEN_TARGET can be the name of a regeneration target (later added with add_cancellation_regeneration_target())
	that will drive regeneration of the reference audio file using the supplied inputs. If not specified, the value of
	the CANCELLATION_REGEN_TARGET directory property will be used, if set.

	Relative paths for all input variables are evaluated relative to CMAKE_CURRENT_SOURCE_DIR.
]]
function (add_plugin_cancellation_test pluginTarget)

	if (NOT TARGET "${pluginTarget}")
		message (
			FATAL_ERROR "${CMAKE_CURRENT_FUNCTION} - plugin target '${pluginTarget}' does not exist!"
		)
	endif ()

	if (NOT PLUGALYZER_PROGRAM)
		return ()
	endif ()

	set (
		oneVal
		# cmake-format: sortable
		BLOCKSIZE
		INPUT_AUDIO
		INPUT_MIDI
		REFERENCE_AUDIO
		REGEN_TARGET
		RMS_THRESH
		SIDECHAIN_INPUT
		STATE_FILE
		TEST_PREFIX
	)

	cmake_parse_arguments (MTM_ARG "" "${oneVal}" "PARAMS" ${ARGN})

	if (NOT MTM_ARG_INPUT_AUDIO)
		message (FATAL_ERROR "${CMAKE_CURRENT_FUNCTION} - missing required argument INPUT_AUDIO")
	endif ()

	cmake_path (ABSOLUTE_PATH MTM_ARG_INPUT_AUDIO BASE_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")

	if (NOT MTM_ARG_REFERENCE_AUDIO)
		message (
			FATAL_ERROR "${CMAKE_CURRENT_FUNCTION} - missing required argument REFERENCE_AUDIO"
		)
	endif ()

	cmake_path (GET MTM_ARG_REFERENCE_AUDIO STEM filename)

	if (NOT MTM_ARG_TEST_PREFIX)
		set (MTM_ARG_TEST_PREFIX "${pluginTarget}.Cancellation.${filename}.")
	endif ()

	cmake_path (ABSOLUTE_PATH MTM_ARG_REFERENCE_AUDIO BASE_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")

	if (MTM_ARG_INPUT_MIDI)
		cmake_path (ABSOLUTE_PATH MTM_ARG_INPUT_MIDI BASE_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")
		set (midi_input_arg "--midiInput=${MTM_ARG_INPUT_MIDI}")
	else ()
		unset (midi_input_arg)
	endif ()

	if (MTM_ARG_STATE_FILE)
		cmake_path (ABSOLUTE_PATH MTM_ARG_STATE_FILE BASE_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")
		set (param_file_arg "--paramFile=${MTM_ARG_STATE_FILE}")
	else ()
		unset (param_file_arg)
	endif ()

	if (MTM_ARG_BLOCKSIZE)
		set (blocksize_arg "--blockSize=${MTM_ARG_BLOCKSIZE}")
	else ()
		unset (blocksize_arg)
	endif ()

	if (MTM_ARG_SIDECHAIN_INPUT)
		cmake_path (
			ABSOLUTE_PATH MTM_ARG_SIDECHAIN_INPUT BASE_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
		)
		set (sidechain_input_arg "--input=${MTM_ARG_SIDECHAIN_INPUT}")
	else ()
		unset (sidechain_input_arg)
	endif ()

	unset (explicit_param_args)

	foreach (param_arg IN LISTS MTM_ARG_PARAMS)
		list (APPEND explicit_param_args "--param=${param_arg}")
	endforeach ()

	set (base_dir "${CMAKE_CURRENT_BINARY_DIR}/cancellation")

	# dummy set up test to create output directory

	set (setup_test "${MTM_ARG_TEST_PREFIX}Prepare")

	add_test (
		NAME "${setup_test}"
		COMMAND "${CMAKE_COMMAND}" -E make_directory "${base_dir}/generated-audio/$<CONFIG>"
	)

	set_tests_properties ("${setup_test}" PROPERTIES FIXTURES_SETUP "${setup_test}")

	# create render test

	cmake_path (GET MTM_ARG_REFERENCE_AUDIO EXTENSION extension)

	set (generated_audio "${base_dir}/generated-audio/$<CONFIG>/${filename}${extension}")

	get_target_property (plugin_artefact "${pluginTarget}" JUCE_PLUGIN_ARTEFACT_FILE)

	set (process_test "${MTM_ARG_TEST_PREFIX}Process")

	# cmake-format: off
	add_test (
		NAME "${process_test}"
		COMMAND
			"${PLUGALYZER_PROGRAM}" process
			"--plugin=${plugin_artefact}"
			"--input=${MTM_ARG_INPUT_AUDIO}" ${sidechain_input_arg}
			"--output=${generated_audio}" --overwrite
			${midi_input_arg} ${blocksize_arg} ${explicit_param_args} ${param_file_arg}
	)

	set_tests_properties (
		"${process_test}"
		PROPERTIES
			REQUIRED_FILES "${MTM_ARG_INPUT_AUDIO};${plugin_artefact}"
			ATTACHED_FILES "${generated_audio};${MTM_ARG_REFERENCE_AUDIO}"
			FIXTURES_SETUP "${process_test}"
			FIXTURES_REQUIRED "${setup_test}"
	)
	# cmake-format: on

	if (MTM_ARG_SIDECHAIN_INPUT)
		set_property (
			TEST "${process_test}" APPEND PROPERTY REQUIRED_FILES "${MTM_ARG_SIDECHAIN_INPUT}"
		)
	endif ()

	if (MTM_ARG_INPUT_MIDI)
		set_property (TEST "${process_test}" APPEND PROPERTY REQUIRED_FILES "${MTM_ARG_INPUT_MIDI}")
	endif ()

	if (MTM_ARG_STATE_FILE)
		set_property (TEST "${process_test}" APPEND PROPERTY REQUIRED_FILES "${MTM_ARG_STATE_FILE}")
	endif ()

	# create diff test

	set (diff_test "${MTM_ARG_TEST_PREFIX}Diff")

	if (NOT MTM_ARG_RMS_THRESH)
		set (MTM_ARG_RMS_THRESH 0.005)
	endif ()

	# cmake-format: off
	add_test (NAME "${diff_test}"
			  COMMAND cancellation::audio_diff
					  "${MTM_ARG_REFERENCE_AUDIO}" "${generated_audio}" "${MTM_ARG_RMS_THRESH}"
	)

	set_tests_properties (
		"${diff_test}"
		PROPERTIES
			FIXTURES_REQUIRED "${process_test}"
			ATTACHED_FILES "${generated_audio};${MTM_ARG_REFERENCE_AUDIO}"
			REQUIRED_FILES "${MTM_ARG_REFERENCE_AUDIO};${generated_audio}"
	)
	# cmake-format: on

	set_property (TEST "${process_test}" "${diff_test}" APPEND PROPERTY LABELS Cancellation)

	set_property (DIRECTORY APPEND PROPERTY ADDITIONAL_CLEAN_FILES "${base_dir}")

	# create regen command

	if (NOT MTM_ARG_REGEN_TARGET)
		get_directory_property (MTM_ARG_REGEN_TARGET CANCELLATION_REGEN_TARGET)

		if (NOT MTM_ARG_REGEN_TARGET)
			return ()
		endif ()
	endif ()

	set (update_reference_output "${MTM_ARG_TEST_PREFIX}${filename}_regenerate")

	if (MTM_ARG_SIDECHAIN_INPUT)
		set (sidechain_depend "${MTM_ARG_SIDECHAIN_INPUT}")
	else ()
		unset (sidechain_depend)
	endif ()

	if (MTM_ARG_INPUT_MIDI)
		set (midi_depend "${MTM_ARG_INPUT_MIDI}")
	else ()
		unset (midi_depend)
	endif ()

	if (MTM_ARG_STATE_FILE)
		set (state_depend "${MTM_ARG_STATE_FILE}")
	else ()
		unset (state_depend)
	endif ()

	# cmake-format: off
	add_custom_command (
		OUTPUT "${update_reference_output}"
		COMMAND
			"${PLUGALYZER_PROGRAM}" process
			"--plugin=${plugin_artefact}"
			"--input=${MTM_ARG_INPUT_AUDIO}" ${sidechain_input_arg}
			"--output=${MTM_ARG_REFERENCE_AUDIO}" --overwrite
			${midi_input_arg} ${blocksize_arg} ${explicit_param_args} ${param_file_arg}
		DEPENDS "${pluginTarget}" "${MTM_ARG_INPUT_AUDIO}" ${sidechain_depend} ${midi_depend} ${state_depend}
		COMMENT "Regenerating reference audio file '${filename}' for plugin cancellation test ${MTM_ARG_TEST_PREFIX}..."
		VERBATIM COMMAND_EXPAND_LISTS
	)
	# cmake-format: on

	set_source_files_properties ("${update_reference_output}" PROPERTIES SYMBOLIC ON)

	set_property (
		DIRECTORY APPEND PROPERTY "${MTM_ARG_REGEN_TARGET}_SymbolicRegenOutputs"
								  "${update_reference_output}"
	)

endfunction ()

#[[
	add_cancellation_regeneration_target (<regenerationTarget>)

	Adds a custom target that, when built, will regenerate a set of reference audio files for cancellation tests.

	When you release a new version or tag of your plugin, manually run this target to update the reference files in your
	source tree. You should then rerun your cancellation tests with the new reference files to verify that everything is
	still working correctly, and then commit the changed reference files into your source control.

	<regenerationTarget> should be the same name you passed to the REGEN_TARGET argument of add_plugin_cancellation_test()
	(or set the CANCELLATION_REGEN_TARGET directory property to before calling that function). This function must be called
	in the same directory as the add_plugin_cancellation_test() calls for the reference files this regeneration target
	needs to regenerate.
]]
function (add_cancellation_regeneration_target regenerationTarget)

	if (NOT PLUGALYZER_PROGRAM)
		return ()
	endif ()

	get_directory_property (outputs "${regenerationTarget}_SymbolicRegenOutputs")

	if (NOT outputs)
		message (
			WARNING
				"${CMAKE_CURRENT_FUNCTION}: No reference file outputs found for regeneration target ${regenerationTarget}."
				" Make sure you've called mtm_add_plugin_cancellation_test() first, and in the same directory as ${CMAKE_CURRENT_FUNCTION}."
		)
		return ()
	endif ()

	# cmake-format: off
	add_custom_target (
		"${regenerationTarget}"
		DEPENDS ${outputs}
		COMMENT "Regenerating cancellation test reference audio files..."
		VERBATIM
	)
	# cmake-format: on

endfunction ()
